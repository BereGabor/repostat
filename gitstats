#!/usr/bin/env python2
# Copyright (c) 2007-2014 Heikki Hokkanen <hoxu@users.sf.net> & others (see doc/AUTHOR)
# GPLv2 / GPLv3
import datetime
import getopt
import glob
import os
import pickle
import re
import shutil
import sys
import time
import zlib
import calendar
from multiprocessing import Pool

from jinja2 import Environment, FileSystemLoader
from tools import GitStatistics
from tools import get_external_execution_time, get_pipe_output

if sys.version_info < (2, 6):
    print >> sys.stderr, "Python 2.6 or higher is required for gitstats"
    sys.exit(1)

os.environ['LC_ALL'] = 'C'

GNUPLOT_COMMON = 'set terminal png transparent size 640,240\nset size 1.0,1.0\n'
WEEKDAYS = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')

exectime_internal = 0.0
time_start = time.time()

# By default, gnuplot is searched from path, but can be overridden with the
# environment variable "GNUPLOT"
gnuplot_cmd = 'gnuplot'
if 'GNUPLOT' in os.environ:
    gnuplot_cmd = os.environ['GNUPLOT']

conf = {
    'max_domains': 10,
    'max_ext_length': 10,
    'style': 'gitstats.css',
    'max_authors': 20,
    'authors_top': 5,
    'commit_begin': '',
    'commit_end': 'HEAD',
    'linear_linestats': 1,
    'project_name': '',
    'processes': 8,
    'start_date': ''
}


def getlogrange(defaultrange = 'HEAD', end_only = True):
    commit_range = getcommitrange(defaultrange, end_only)
    if len(conf['start_date']) > 0:
        return '--since="%s" "%s"' % (conf['start_date'], commit_range)
    return commit_range


def getcommitrange(defaultrange = 'HEAD', end_only = False):
    if len(conf['commit_end']) > 0:
        if end_only or len(conf['commit_begin']) == 0:
            return conf['commit_end']
        return '%s..%s' % (conf['commit_begin'], conf['commit_end'])
    return defaultrange


def getkeyssortedbyvalues(dict):
    return map(lambda el : el[1], sorted(map(lambda el : (el[1], el[0]), dict.items())))

# dict['author'] = { 'commits': 512 } - ...key(dict, 'commits')
def getkeyssortedbyvaluekey(d, key):
    return map(lambda el : el[1], sorted(map(lambda el : (d[el][key], el), d.keys())))


def getstatsummarycounts(line):
    numbers = re.findall('\d+', line)
    if   len(numbers) == 1:
        # neither insertions nor deletions: may probably only happen for "0 files changed"
        numbers.append(0);
        numbers.append(0);
    elif len(numbers) == 2 and line.find('(+)') != -1:
        numbers.append(0);    # only insertions were printed on line
    elif len(numbers) == 2 and line.find('(-)') != -1:
        numbers.insert(1, 0); # only deletions were printed on line
    return numbers


VERSION = 0
def getversion():
    global VERSION
    if VERSION == 0:
        gitstats_repo = os.path.dirname(os.path.abspath(__file__))
        VERSION = get_pipe_output(["git --git-dir=%s/.git --work-tree=%s rev-parse --short %s" %
            (gitstats_repo, gitstats_repo, getcommitrange('HEAD').split('\n')[0])])
    return VERSION


def getgitversion():
    return get_pipe_output(['git --version']).split('\n')[0]


def getgnuplotversion():
    return get_pipe_output(['%s --version' % gnuplot_cmd]).split('\n')[0]


def getnumoffilesfromrev(time_rev):
    """
    Get number of files changed in commit
    """
    time, rev = time_rev
    return (int(time), rev, int(get_pipe_output(['git ls-tree -r --name-only "%s"' % rev, 'wc -l']).split('\n')[0]))


def getnumoflinesinblob(ext_blob):
    """
    Get number of lines in blob
    """
    ext, blob_id = ext_blob
    return (ext, blob_id, int(get_pipe_output(['git cat-file blob %s' % blob_id, 'wc -l']).split()[0]))


class DataCollector:
    """Manages data collection from a revision control repository."""
    def __init__(self):
        self.stamp_created = time.time()
        self.cache = {}
        self.total_authors = 0
        self.activity_by_hour_of_day = {} # hour -> commits
        self.activity_by_day_of_week = {} # day -> commits
        self.activity_by_month_of_year = {} # month [1-12] -> commits
        self.activity_by_hour_of_week = {} # weekday -> hour -> commits
        self.activity_by_hour_of_day_busiest = 0
        self.activity_by_hour_of_week_busiest = 0
        self.activity_by_year_week = {} # yy_wNN -> commits
        self.activity_by_year_week_peak = 0

        self.authors = {} # name -> {commits, first_commit_stamp, last_commit_stamp, last_active_day, active_days, lines_added, lines_removed}

        self.total_commits = 0
        self.total_files = 0
        self.authors_by_commits = 0

        # domains
        self.domains = {} # domain -> commits

        # author of the month
        self.author_of_month = {} # month -> author -> commits
        self.author_of_year = {} # year -> author -> commits
        self.commits_by_month = {} # month -> commits
        self.commits_by_year = {} # year -> commits
        self.lines_added_by_month = {} # month -> lines added
        self.lines_added_by_year = {} # year -> lines added
        self.lines_removed_by_month = {} # month -> lines removed
        self.lines_removed_by_year = {} # year -> lines removed
        self.first_commit_stamp = 0
        self.last_commit_stamp = 0
        self.last_active_day = None
        self.active_days = set()

        # lines
        self.total_lines = 0
        self.total_lines_added = 0
        self.total_lines_removed = 0

        # size
        self.total_size = 0

        # timezone
        self.commits_by_timezone = {} # timezone -> commits

        # tags
        self.tags = {}

        self.files_by_stamp = {} # stamp -> files

        # extensions
        self.extensions = {} # extension -> files, lines

        # line statistics
        self.changes_by_date = {} # stamp -> { files, ins, del }

    ##
    # This should be the main function to extract data from the repository.
    def collect(self, dir):
        self.dir = dir
        if len(conf['project_name']) == 0:
            self.projectname = os.path.basename(os.path.abspath(dir))
        else:
            self.projectname = conf['project_name']

    ##
    # Load cacheable data
    def loadCache(self, cachefile):
        if not os.path.exists(cachefile):
            return
        print 'Loading cache...'
        f = open(cachefile, 'rb')
        try:
            self.cache = pickle.loads(zlib.decompress(f.read()))
        except:
            # temporary hack to upgrade non-compressed caches
            f.seek(0)
            self.cache = pickle.load(f)
        f.close()

    ##
    # Produce any additional statistics from the extracted data.
    def refine(self):
        pass

    ##
    # : get a dictionary of author
    def getAuthorInfo(self, author):
        return None

    def getActivityByDayOfWeek(self):
        return {}

    def getActivityByHourOfDay(self):
        return {}

    # : get a dictionary of domains
    def getDomainInfo(self, domain):
        return None

    ##
    # Get a list of authors
    def getAuthors(self):
        return []

    def getFirstCommitDate(self):
        return datetime.datetime.now()

    def getLastCommitDate(self):
        return datetime.datetime.now()

    def getStampCreated(self):
        return self.stamp_created

    def getTags(self):
        return []

    def getTotalAuthors(self):
        return -1

    def getTotalCommits(self):
        return -1

    def getTotalFiles(self):
        return -1

    def getTotalLOC(self):
        return -1

    ##
    # Save cacheable data
    def saveCache(self, cachefile):
        print 'Saving cache...'
        tempfile = cachefile + '.tmp'
        f = open(tempfile, 'wb')
        #pickle.dump(self.cache, f)
        data = zlib.compress(pickle.dumps(self.cache))
        f.write(data)
        f.close()
        try:
            os.remove(cachefile)
        except OSError:
            pass
        os.rename(tempfile, cachefile)


class GitDataCollector(DataCollector):
    def collect(self, dir):
        DataCollector.collect(self, dir)

        repo_statistics = GitStatistics(dir)

        self.authors = repo_statistics.authors
        self.total_authors = len(repo_statistics.authors)
        self.tags = repo_statistics.tags
        self.domains = repo_statistics.domains
        self.commits_by_timezone = repo_statistics.timezones

        # Collect revision statistics
        # Outputs "<stamp> <date> <time> <timezone> <author> '<' <mail> '>'"
        lines = get_pipe_output(['git rev-list --pretty=format:"%%at %%ai %%aN <%%aE>" %s' % getlogrange('HEAD'), 'grep -v ^commit']).split('\n')
        for line in lines:
            parts = line.split(' ', 4)
            try:
                stamp = int(parts[0])
            except ValueError:
                stamp = 0
            author, mail = parts[4].split('<', 1)
            author = author.rstrip()
            date = datetime.datetime.fromtimestamp(float(stamp))

            # First and last commit stamp (may be in any order because of cherry-picking and patches)
            if stamp > self.last_commit_stamp:
                self.last_commit_stamp = stamp
            if self.first_commit_stamp == 0 or stamp < self.first_commit_stamp:
                self.first_commit_stamp = stamp

            # activity
            # hour
            hour = date.hour
            self.activity_by_hour_of_day[hour] = self.activity_by_hour_of_day.get(hour, 0) + 1
            # most active hour?
            if self.activity_by_hour_of_day[hour] > self.activity_by_hour_of_day_busiest:
                self.activity_by_hour_of_day_busiest = self.activity_by_hour_of_day[hour]

            # day of week
            day = date.weekday()
            self.activity_by_day_of_week[day] = self.activity_by_day_of_week.get(day, 0) + 1

            # hour of week
            if day not in self.activity_by_hour_of_week:
                self.activity_by_hour_of_week[day] = {}
            self.activity_by_hour_of_week[day][hour] = self.activity_by_hour_of_week[day].get(hour, 0) + 1
            # most active hour?
            if self.activity_by_hour_of_week[day][hour] > self.activity_by_hour_of_week_busiest:
                self.activity_by_hour_of_week_busiest = self.activity_by_hour_of_week[day][hour]

            # month of year
            month = date.month
            self.activity_by_month_of_year[month] = self.activity_by_month_of_year.get(month, 0) + 1

            # yearly/weekly activity
            yyw = date.strftime('%Y-%W')
            self.activity_by_year_week[yyw] = self.activity_by_year_week.get(yyw, 0) + 1
            if self.activity_by_year_week_peak < self.activity_by_year_week[yyw]:
                self.activity_by_year_week_peak = self.activity_by_year_week[yyw]

            # author of the month/year
            yymm = date.strftime('%Y-%m')
            if yymm in self.author_of_month:
                self.author_of_month[yymm][author] = self.author_of_month[yymm].get(author, 0) + 1
            else:
                self.author_of_month[yymm] = {}
                self.author_of_month[yymm][author] = 1
            self.commits_by_month[yymm] = self.commits_by_month.get(yymm, 0) + 1

            yy = date.year
            if yy in self.author_of_year:
                self.author_of_year[yy][author] = self.author_of_year[yy].get(author, 0) + 1
            else:
                self.author_of_year[yy] = {}
                self.author_of_year[yy][author] = 1
            self.commits_by_year[yy] = self.commits_by_year.get(yy, 0) + 1

            yymmdd = date.strftime('%Y-%m-%d')
            # project: active days
            if yymmdd != self.last_active_day:
                self.last_active_day = yymmdd
                self.active_days.add(yymmdd)

        # outputs "<stamp> <files>" for each revision
        revlines = get_pipe_output(['git rev-list --pretty=format:"%%at %%T" %s' % getlogrange('HEAD'), 'grep -v ^commit']).strip().split('\n')
        lines = []
        revs_to_read = []
        #Look up rev in cache and take info from cache if found
        #If not append rev to list of rev to read from repo
        for revline in revlines:
            time, rev = revline.split(' ')
            #if cache empty then add time and rev to list of new rev's
            #otherwise try to read needed info from cache
            if 'files_in_tree' not in self.cache.keys():
                revs_to_read.append((time,rev))
                continue
            if rev in self.cache['files_in_tree'].keys():
                lines.append('%d %d' % (int(time), self.cache['files_in_tree'][rev]))
            else:
                revs_to_read.append((time,rev))

        #Read revisions from repo
        pool = Pool(processes=conf['processes'])
        time_rev_count = pool.map(getnumoffilesfromrev, revs_to_read)
        pool.terminate()
        pool.join()

        #Update cache with new revisions and append then to general list
        for (time, rev, count) in time_rev_count:
            if 'files_in_tree' not in self.cache:
                self.cache['files_in_tree'] = {}
            self.cache['files_in_tree'][rev] = count
            lines.append('%d %d' % (int(time), count))

        self.total_commits += len(lines)
        for line in lines:
            parts = line.split(' ')
            if len(parts) != 2:
                continue
            (stamp, files) = parts[0:2]
            try:
                self.files_by_stamp[int(stamp)] = int(files)
            except ValueError:
                print 'Warning: failed to parse line "%s"' % line

        # extensions and size of files
        lines = get_pipe_output(['git ls-tree -r -l -z %s' % getcommitrange('HEAD', end_only = True)]).split('\000')
        blobs_to_read = []
        for line in lines:
            if len(line) == 0:
                continue
            parts = re.split('\s+', line, 4)
            if parts[0] == '160000' and parts[3] == '-':
                # skip submodules
                continue
            blob_id = parts[2]
            size = int(parts[3])
            fullpath = parts[4]

            self.total_size += size
            self.total_files += 1

            filename = fullpath.split('/')[-1] # strip directories
            if filename.find('.') == -1 or filename.rfind('.') == 0:
                ext = ''
            else:
                ext = filename[(filename.rfind('.') + 1):]
            if len(ext) > conf['max_ext_length']:
                ext = ''
            if ext not in self.extensions:
                self.extensions[ext] = {'files': 0, 'lines': 0}
            self.extensions[ext]['files'] += 1
            #if cache empty then add ext and blob id to list of new blob's
            #otherwise try to read needed info from cache
            if 'lines_in_blob' not in self.cache.keys():
                blobs_to_read.append((ext,blob_id))
                continue
            if blob_id in self.cache['lines_in_blob'].keys():
                self.extensions[ext]['lines'] += self.cache['lines_in_blob'][blob_id]
            else:
                blobs_to_read.append((ext,blob_id))

        #Get info abount line count for new blob's that wasn't found in cache
        pool = Pool(processes=conf['processes'])
        ext_blob_linecount = pool.map(getnumoflinesinblob, blobs_to_read)
        pool.terminate()
        pool.join()

        #Update cache and write down info about number of number of lines
        for (ext, blob_id, linecount) in ext_blob_linecount:
            if 'lines_in_blob' not in self.cache:
                self.cache['lines_in_blob'] = {}
            self.cache['lines_in_blob'][blob_id] = linecount
            self.extensions[ext]['lines'] += self.cache['lines_in_blob'][blob_id]

        # line statistics
        # outputs:
        #  N files changed, N insertions (+), N deletions(-)
        # <stamp> <author>
        self.changes_by_date = {} # stamp -> { files, ins, del }
        # computation of lines of code by date is better done
        # on a linear history.
        extra = ''
        if conf['linear_linestats']:
            extra = '--first-parent -m'
        lines = get_pipe_output(['git log --shortstat %s --pretty=format:"%%at %%aN" %s' % (extra, getlogrange('HEAD'))]).split('\n')
        lines.reverse()
        files = 0; inserted = 0; deleted = 0; total_lines = 0
        author = None
        for line in lines:
            if len(line) == 0:
                continue

            # <stamp> <author>
            if re.search('files? changed', line) == None:
                pos = line.find(' ')
                if pos != -1:
                    try:
                        (stamp, author) = (int(line[:pos]), line[pos+1:])
                        self.changes_by_date[stamp] = { 'files': files, 'ins': inserted, 'del': deleted, 'lines': total_lines }

                        date = datetime.datetime.fromtimestamp(stamp)
                        yymm = date.strftime('%Y-%m')
                        self.lines_added_by_month[yymm] = self.lines_added_by_month.get(yymm, 0) + inserted
                        self.lines_removed_by_month[yymm] = self.lines_removed_by_month.get(yymm, 0) + deleted

                        yy = date.year
                        self.lines_added_by_year[yy] = self.lines_added_by_year.get(yy,0) + inserted
                        self.lines_removed_by_year[yy] = self.lines_removed_by_year.get(yy, 0) + deleted

                        files, inserted, deleted = 0, 0, 0
                    except ValueError:
                        print 'Warning: unexpected line "%s"' % line
                else:
                    print 'Warning: unexpected line "%s"' % line
            else:
                numbers = getstatsummarycounts(line)

                if len(numbers) == 3:
                    (files, inserted, deleted) = map(lambda el : int(el), numbers)
                    total_lines += inserted
                    total_lines -= deleted
                    self.total_lines_added += inserted
                    self.total_lines_removed += deleted

                else:
                    print 'Warning: failed to handle line "%s"' % line
                    (files, inserted, deleted) = (0, 0, 0)
                #self.changes_by_date[stamp] = { 'files': files, 'ins': inserted, 'del': deleted }
        self.total_lines += total_lines

        # Per-author statistics

        # defined for stamp, author only if author commited at this timestamp.
        self.changes_by_date_by_author = {} # stamp -> author -> lines_added

        # Similar to the above, but never use --first-parent
        # (we need to walk through every commit to know who
        # committed what, not just through mainline)
        lines = get_pipe_output(['git log --shortstat --date-order --pretty=format:"%%at %%aN" %s' % (getlogrange('HEAD'))]).split('\n')
        lines.reverse()
        inserted = 0
        stamp = 0
        # remove this when changes_by_date_by_author is migrated to pygit2
        tmp_authors = {}
        for line in lines:
            if len(line) == 0:
                continue

            # <stamp> <author>
            if re.search('files? changed', line) == None:
                pos = line.find(' ')
                if pos != -1:
                    try:
                        oldstamp = stamp
                        (stamp, author) = (int(line[:pos]), line[pos+1:])
                        if oldstamp > stamp:
                            # clock skew, keep old timestamp to avoid having ugly graph
                            stamp = oldstamp
                        if author not in tmp_authors:
                            tmp_authors[author] = {'lines_added': 0, 'commits': 0}
                        tmp_authors[author]['commits'] = tmp_authors[author].get('commits', 0) + 1
                        tmp_authors[author]['lines_added'] = tmp_authors[author].get('lines_added', 0) + inserted
                        if stamp not in self.changes_by_date_by_author:
                            self.changes_by_date_by_author[stamp] = {}
                        if author not in self.changes_by_date_by_author[stamp]:
                            self.changes_by_date_by_author[stamp][author] = {}
                        self.changes_by_date_by_author[stamp][author]['lines_added'] = tmp_authors[author]['lines_added']
                        self.changes_by_date_by_author[stamp][author]['commits'] = tmp_authors[author]['commits']
                        files, inserted, deleted = 0, 0, 0
                    except ValueError:
                        print 'Warning: unexpected line "%s"' % line
                else:
                    print 'Warning: unexpected line "%s"' % line
            else:
                numbers = getstatsummarycounts(line)

                if len(numbers) == 3:
                    (files, inserted, deleted) = map(lambda el : int(el), numbers)
                else:
                    print 'Warning: failed to handle line "%s"' % line
                    (files, inserted, deleted) = (0, 0, 0)

    def refine(self):
        # authors
        # name -> {place_by_commits, commits_frac, date_first, date_last, timedelta}
        self.authors_by_commits = getkeyssortedbyvaluekey(self.authors, 'commits')
        self.authors_by_commits.reverse() # most first
        for i, name in enumerate(self.authors_by_commits):
            self.authors[name]['place_by_commits'] = i + 1

        for name in self.authors.keys():
            a = self.authors[name]
            a['commits_frac'] = (100 * float(a['commits'])) / self.getTotalCommits()
            date_first = datetime.datetime.fromtimestamp(a['first_commit_stamp'])
            date_last = datetime.datetime.fromtimestamp(a['last_commit_stamp'])
            delta = date_last - date_first
            a['date_first'] = date_first.strftime('%Y-%m-%d')
            a['date_last'] = date_last.strftime('%Y-%m-%d')
            a['timedelta'] = delta
            if 'lines_added' not in a: a['lines_added'] = 0
            if 'lines_removed' not in a: a['lines_removed'] = 0

    def getActiveDays(self):
        return self.active_days

    def getActivityByDayOfWeek(self):
        return self.activity_by_day_of_week

    def getActivityByHourOfDay(self):
        return self.activity_by_hour_of_day

    def getAuthorInfo(self, author):
        return self.authors[author]

    def getAuthors(self, limit = None):
        res = getkeyssortedbyvaluekey(self.authors, 'commits')
        res.reverse()
        return res[:limit]

    def getCommitDeltaDays(self):
        return (self.last_commit_stamp / 86400 - self.first_commit_stamp / 86400) + 1

    def getDomainInfo(self, domain):
        return self.domains[domain]

    def getDomains(self):
        return self.domains.keys()

    def getFirstCommitDate(self):
        return datetime.datetime.fromtimestamp(self.first_commit_stamp)

    def getLastCommitDate(self):
        return datetime.datetime.fromtimestamp(self.last_commit_stamp)

    def getTags(self):
        lines = get_pipe_output(['git show-ref --tags', 'cut -d/ -f3'])
        return lines.split('\n')

    def getTagDate(self, tag):
        return self.revToDate('tags/' + tag)

    def getTotalAuthors(self):
        return self.total_authors

    def getTotalCommits(self):
        return self.total_commits

    def getTotalFiles(self):
        return self.total_files

    def getTotalLOC(self):
        return self.total_lines

    def getTotalSize(self):
        return self.total_size

    def revToDate(self, rev):
        stamp = int(get_pipe_output(['git log --pretty=format:%%at "%s" -n 1' % rev]))
        return datetime.datetime.fromtimestamp(stamp).strftime('%Y-%m-%d')


class ReportCreator:
    """Creates the actual report based on given data."""
    def __init__(self):
        pass

    def create(self, data, path):
        self.data = data
        self.path = path


class HTMLReportCreator(ReportCreator):
    def create(self, data, path):
        ReportCreator.create(self, data, path)
        self.title = data.projectname

        # copy static files. Looks in the binary directory, ../share/gitstats and /usr/share/gitstats
        binarypath = os.path.dirname(os.path.abspath(__file__))
        secondarypath = os.path.join(binarypath, '..', 'share', 'gitstats')
        basedirs = [binarypath, secondarypath, '/usr/share/gitstats']
        for file in (conf['style'], 'sortable.js', 'arrow-up.gif', 'arrow-down.gif', 'arrow-none.gif'):
            for base in basedirs:
                src = base + '/' + file
                if os.path.exists(src):
                    shutil.copyfile(src, path + '/' + file)
                    break
            else:
                print 'Warning: "%s" not found, so not copied (searched: %s)' % (file, basedirs)

        ###
        # General
        general_html = self.render_general_page(data)
        with open(os.path.join(path, "general.html"), 'w') as f:
            f.write(general_html)

        ###
        # Activity
        activity_html = self.render_activity_page(data)
        with open(os.path.join(path, "activity.html"), 'w') as f:
            f.write(activity_html)

        # Weekly activity
        WEEKS = 32

        # generate weeks to show (previous N weeks from now)
        now = datetime.datetime.now()
        deltaweek = datetime.timedelta(7)
        weeks = []
        stampcur = now
        for i in range(0, WEEKS):
            weeks.insert(0, stampcur.strftime('%Y-%W'))
            stampcur -= deltaweek

        # Hour of Day
        hour_of_day = data.getActivityByHourOfDay()
        fg = open(path + '/hour_of_day.dat', 'w')
        for i in range(0, 24):
            if i in hour_of_day:
                fg.write('%d %d\n' % (i + 1, hour_of_day[i]))
            else:
                fg.write('%d 0\n' % (i + 1))
        fg.close()

        # Day of Week
        day_of_week = data.getActivityByDayOfWeek()
        fp = open(path + '/day_of_week.dat', 'w')
        for d in range(0, 7):
            commits = 0
            if d in day_of_week:
                commits = day_of_week[d]
            fp.write('%d %s %d\n' % (d + 1, WEEKDAYS[d], commits))
        fp.close()

        # Month of Year
        fp = open (path + '/month_of_year.dat', 'w')
        for mm in range(1, 13):
            commits = 0
            if mm in data.activity_by_month_of_year:
                commits = data.activity_by_month_of_year[mm]
            fp.write('%d %d\n' % (mm, commits))
        fp.close()

        # Commits by year/month
        fg = open(path + '/commits_by_year_month.dat', 'w')
        for yymm in sorted(data.commits_by_month.keys()):
            fg.write('%s %s\n' % (yymm, data.commits_by_month[yymm]))
        fg.close()

        # Commits by year
        fg = open(path + '/commits_by_year.dat', 'w')
        for yy in sorted(data.commits_by_year.keys()):
            fg.write('%d %d\n' % (yy, data.commits_by_year[yy]))
        fg.close()

        ###
        # Authors
        authors_html = self.render_authors_page(data)
        with open(os.path.join(path, "authors.html"), 'w') as f:
            f.write(authors_html)

        fgl = open(path + '/lines_of_code_by_author.dat', 'w')
        fgc = open(path + '/commits_by_author.dat', 'w')

        lines_by_authors = {} # cumulated added lines by
        # author. to save memory,
        # changes_by_date_by_author[stamp][author] is defined
        # only at points where author commits.
        # lines_by_authors allows us to generate all the
        # points in the .dat file.

        # Don't rely on getAuthors to give the same order each
        # time. Be robust and keep the list in a variable.
        commits_by_authors = {} # cumulated added lines by

        self.authors_to_plot = data.getAuthors(conf['max_authors'])
        for author in self.authors_to_plot:
            lines_by_authors[author] = 0
            commits_by_authors[author] = 0
        for stamp in sorted(data.changes_by_date_by_author.keys()):
            fgl.write('%d' % stamp)
            fgc.write('%d' % stamp)
            for author in self.authors_to_plot:
                if author in data.changes_by_date_by_author[stamp].keys():
                    lines_by_authors[author] = data.changes_by_date_by_author[stamp][author]['lines_added']
                    commits_by_authors[author] = data.changes_by_date_by_author[stamp][author]['commits']
                fgl.write(' %d' % lines_by_authors[author])
                fgc.write(' %d' % commits_by_authors[author])
            fgl.write('\n')
            fgc.write('\n')
        fgl.close()
        fgc.close()

        # Domains
        domains_by_commits = getkeyssortedbyvaluekey(data.domains, 'commits')
        domains_by_commits.reverse() # most first
        fp = open(path + '/domains.dat', 'w')
        n = 0
        for domain in domains_by_commits:
            if n == conf['max_domains']:
                break
            commits = 0
            n += 1
            info = data.getDomainInfo(domain)
            fp.write('%s %d %d\n' % (domain, n , info['commits']))
        fp.close()

        ###
        # Files
        files_html = self.render_files_page(data)
        with open(os.path.join(path, "files.html"), 'w') as f:
            f.write(files_html)

        # FIXME: check if this is still needed
        # use set to get rid of duplicate/unnecessary entries
        files_by_date = set()
        for stamp in sorted(data.files_by_stamp.keys()):
            files_by_date.add('%s %d' % (datetime.datetime.fromtimestamp(stamp).strftime('%Y-%m-%d'), data.files_by_stamp[stamp]))

        fg = open(path + '/files_by_date.dat', 'w')
        for line in sorted(list(files_by_date)):
            fg.write('%s\n' % line)
        #for stamp in sorted(data.files_by_stamp.keys()):
        #	fg.write('%s %d\n' % (datetime.datetime.fromtimestamp(stamp).strftime('%Y-%m-%d'), data.files_by_stamp[stamp]))
        fg.close()

        ###
        # Lines
        with open(path + '/lines_of_code.dat', 'w') as fg:
            for stamp in sorted(data.changes_by_date.keys()):
                fg.write('%d %d\n' % (stamp, data.changes_by_date[stamp]['lines']))

        lines_html = self.render_lines_page(data)
        with open(os.path.join(path, "lines.html"), 'w') as f:
            f.write(lines_html)

        ###
        # tags.html
        tags_html = self.render_tags_page(data)
        with open(os.path.join(path, "tags.html"), 'w') as f:
            f.write(tags_html)

        self.createGraphs(path)

    def render_general_page(self, data):
        date_format_str = '%Y-%m-%d %H:%M'
        # TODO: this conversion from old 'data' to new 'project data' should perhaps be removed in future
        project_data = {
            "name": data.projectname,
            "url": "https://github.com/vifactor/repostat",
            "version": getversion(),
            "tools": [getgitversion(), getgnuplotversion()],
            "age": data.getCommitDeltaDays(),
            "active_days_count": len(data.getActiveDays()),
            "active_days_ratio": "{0:.2f}".format((100.0 * len(data.getActiveDays()) / data.getCommitDeltaDays())),
            "commits_count": data.getTotalCommits(),
            "commits_per_active_day_count": "{0:.2f}".format(float(data.getTotalCommits()) / len(data.getActiveDays())),
            "commits_per_day_count": "{0:.2f}".format(float(data.getTotalCommits()) / data.getCommitDeltaDays()),
            "authors_count": data.getTotalAuthors(),
            "commits_per_author_count": "{0:.2f}".format(float(data.getTotalCommits()) / data.getTotalAuthors()),
            "files_count": data.getTotalFiles(),
            "total_lines_count": data.getTotalLOC(),
            "added_lines_count": data.total_lines_added,
            "removed_lines_count": data.total_lines_removed,
            "first_commit_date": data.getFirstCommitDate().strftime(date_format_str),
            "last_commit_date": data.getLastCommitDate().strftime(date_format_str)
        }

        generation_data = {
            "datetime": datetime.datetime.today().strftime(date_format_str),
            "duration": "{0:.3f}".format(time.time() - data.getStampCreated())
        }

        # load and render template
        code_dir = os.path.dirname(os.path.abspath(__file__))
        templates_dir = os.path.join(code_dir, 'templates')
        j2_env = Environment(loader=FileSystemLoader(templates_dir), trim_blocks=True)

        template_rendered = j2_env.get_template('general.html').render(
            project=project_data,
            generation=generation_data,
            page_title="General"
        )
        return template_rendered

    def render_activity_page(self, data):
        # TODO: this conversion from old 'data' to new 'project data' should perhaps be removed in future
        activity_period_weeks = 32
        project_data = {
            'recent_activity': [],
            'hourly_activity': [],
            'weekday_hourly_activity': {},
            'timezones_activity': []
        }

        # generate weeks to show (previous N weeks from now)
        now = datetime.datetime.now()
        deltaweek = datetime.timedelta(7)
        weeks = []
        stampcur = now
        for i in range(0, activity_period_weeks):
            weeks.insert(0, stampcur.strftime('%Y-%W'))
            stampcur -= deltaweek

        # top row: commits & bar
        for i in range(0, activity_period_weeks):
            commits = 0
            if weeks[i] in data.activity_by_year_week:
                commits = data.activity_by_year_week[weeks[i]]

            percentage = 0
            if weeks[i] in data.activity_by_year_week:
                percentage = float(data.activity_by_year_week[weeks[i]]) / data.activity_by_year_week_peak
            bar_height = max(1, int(200 * percentage))
            project_data['recent_activity'].append((commits, bar_height))

        totalcommits = data.getTotalCommits()
        hour_of_day = data.getActivityByHourOfDay()
        for i in range(0, 24):
            if i in hour_of_day:
                r = 127 + int((float(hour_of_day[i]) / data.activity_by_hour_of_day_busiest) * 128)
                project_data['hourly_activity'].append({'intensity': r, 'commits_count': hour_of_day[i], 'relative_commits_count': (100.0 * hour_of_day[i]) / totalcommits})
            else:
                project_data['hourly_activity'].append({'intensity': 0, 'commits_count': 0, 'relative_commits_count': 0.00})

        for weekday, weekday_name in enumerate(calendar.day_name):
            project_data['weekday_hourly_activity'][weekday_name] = []
            for hour in range(0, 24):
                try:
                    commits = data.activity_by_hour_of_week[weekday][hour]
                except KeyError:
                    commits = 0
                if commits != 0:
                    r = 127 + int((float(commits) / data.activity_by_hour_of_week_busiest) * 128)
                    project_data['weekday_hourly_activity'][weekday_name].append((r, commits))
                else:
                    project_data['weekday_hourly_activity'][weekday_name].append((0, commits))

        max_commits_on_tz = max(data.commits_by_timezone.values())
        for i in sorted(data.commits_by_timezone.keys(), key = lambda n: int(n)):
            commits = data.commits_by_timezone[i]
            r = 127 + int((float(commits) / max_commits_on_tz) * 128)
            project_data['timezones_activity'].append((i, r, commits))

        # load and render template
        code_dir = os.path.dirname(os.path.abspath(__file__))
        templates_dir = os.path.join(code_dir, 'templates')
        j2_env = Environment(loader=FileSystemLoader(templates_dir), trim_blocks=True)

        template_rendered = j2_env.get_template('activity.html').render(
            project=project_data,
            page_title="Activity"
        )
        return template_rendered

    def render_authors_page(self, data):
        # TODO: this conversion from old 'data' to new 'project data' should perhaps be removed in future
        project_data = {
            'top_authors': [],
            'non_top_authors': []
        }

        all_authors = data.getAuthors()
        all_authors = [author.decode('utf-8') for author in all_authors]
        if len(all_authors) > conf['max_authors']:
            rest = all_authors[conf['max_authors']:]
            project_data['non_top_authors'] = rest

        project_data['months'] = []
        for yymm in reversed(sorted(data.author_of_month.keys())):
            authordict = data.author_of_month[yymm]
            authors = getkeyssortedbyvalues(authordict)
            authors.reverse()
            commits = data.author_of_month[yymm][authors[0]]
            next = ', '.join(authors[1:conf['authors_top']+1])

            month_dict = {
                'date': yymm,
                'top_author': {'name': authors[0].decode('utf-8'), 'commits_count': commits},
                'next_top_authors': next.decode('utf-8'),
                'all_commits_count': data.commits_by_month[yymm]
            }
            project_data['months'].append(month_dict)

        project_data['years'] = []
        for yy in reversed(sorted(data.author_of_year.keys())):
            authordict = data.author_of_year[yy]
            authors = getkeyssortedbyvalues(authordict)
            authors.reverse()
            commits = data.author_of_year[yy][authors[0]]
            next = ', '.join(authors[1:conf['authors_top']+1])

            year_dict = {
                'date': yy,
                'top_author': {'name': authors[0].decode('utf-8'), 'commits_count': commits},
                'next_top_authors': next.decode('utf-8'),
                'all_commits_count': data.commits_by_year[yy]
            }
            project_data['years'].append(year_dict)

        for author in all_authors[:conf['max_authors']]:
            info = data.getAuthorInfo(author)
            author_dict = {
                'name': author,
                'commits_count': info['commits'],
                'commits_relative_count': info['commits_frac'],
                'lines_added_count': info['lines_added'],
                'lines_removed_count': info['lines_removed'],
                'first_commit_date': info['date_first'],
                'latest_commit_date': info['date_last'],
                'contributed_days_count': info['timedelta'],
                'active_days_count': len(info['active_days']),
            }

            project_data['top_authors'].append(author_dict)

        # load and render template
        code_dir = os.path.dirname(os.path.abspath(__file__))
        templates_dir = os.path.join(code_dir, 'templates')
        j2_env = Environment(loader=FileSystemLoader(templates_dir), trim_blocks=True)

        template_rendered = j2_env.get_template('authors.html').render(
            project=project_data,
            page_title="Authors"
        )
        return template_rendered.encode('utf-8')

    def render_files_page(self, data):
        # TODO: this conversion from old 'data' to new 'project data' should perhaps be removed in future
        project_data = {
            'files_count': data.getTotalFiles(),
            'size': data.getTotalSize(),
            'average_file_size': "{0:.2f}".format(float(data.getTotalSize()) / data.getTotalFiles()),
            'files': []
        }

        for ext in sorted(data.extensions.keys()):
            files = data.extensions[ext]['files']
            lines = data.extensions[ext]['lines']
            try:
                loc_percentage = (100.0 * lines) / data.getTotalLOC()
            except ZeroDivisionError:
                loc_percentage = 0
            file_type_dict = {"extension": ext,
                              "count": files,
                              "relative_count": "{0:.2f}".format((100.0 * files) / data.getTotalFiles()),
                              "lines_count": lines,
                              "relative_lines_count": "{0:.2f}".format(loc_percentage),
                              "lines_per_file_count": "{0:.1f}".format(lines / files)
                              }
            project_data['files'].append(file_type_dict)

        # load and render template
        code_dir = os.path.dirname(os.path.abspath(__file__))
        templates_dir = os.path.join(code_dir, 'templates')
        j2_env = Environment(loader=FileSystemLoader(templates_dir), trim_blocks=True)

        template_rendered = j2_env.get_template('files.html').render(
            project=project_data,
            page_title="Files"
        )
        return template_rendered

    def render_lines_page(self, data):
        # TODO: this conversion from old 'data' to new 'project data' should perhaps be removed in future
        project_data = {
            "total_lines_count": data.getTotalLOC(),
            "added_lines_count": data.total_lines_added,
            "removed_lines_count": data.total_lines_removed
        }

        # load and render template
        code_dir = os.path.dirname(os.path.abspath(__file__))
        templates_dir = os.path.join(code_dir, 'templates')
        j2_env = Environment(loader=FileSystemLoader(templates_dir), trim_blocks=True)

        template_rendered = j2_env.get_template('lines.html').render(
            project=project_data,
            page_title="Lines"
        )
        return template_rendered

    def render_tags_page(self, data):
        # TODO: this conversion from old 'data' to new 'project data' should perhaps be removed in future
        project_data = {
            'tags_count': len(data.tags),
            'tags': []
        }

        # TODO: fix error occuring when a tag name and project name are the same
        """
        fatal: ambiguous argument 'gitstats': both revision and filename
        Use '--' to separate paths from revisions, like this:
        'git <command> [<revision>...] -- [<file>...]'
        """

        # TODO: refactor the following code
        tags_sorted_by_date_desc = map(lambda el: el[1],
                                       reversed(sorted(map(lambda el: (el[1]['date'], el[0]), data.tags.items()))))
        for tag in tags_sorted_by_date_desc:
            authorinfo = []
            self.authors_by_commits = getkeyssortedbyvalues(data.tags[tag]['authors'])
            for i in reversed(self.authors_by_commits):
                authorinfo.append('%s (%d)' % (i, data.tags[tag]['authors'][i]))
            print authorinfo
            tag_dict = {
                'name': tag,
                'date': data.tags[tag]['date'],
                'commits_count': data.tags[tag]['commits'],
                'authors': ', '.join(authorinfo)
            }
            project_data['tags'].append(tag_dict)

        # load and render template
        code_dir = os.path.dirname(os.path.abspath(__file__))
        templates_dir = os.path.join(code_dir, 'templates')
        j2_env = Environment(loader=FileSystemLoader(templates_dir), trim_blocks=True)

        template_rendered = j2_env.get_template('tags.html').render(
            project=project_data,
            page_title="Tags"
        )
        return template_rendered.encode('utf-8')

    def createGraphs(self, path):
        print 'Generating graphs...'

        # hour of day
        f = open(path + '/hour_of_day.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'hour_of_day.png'
unset key
set xrange [0.5:24.5]
set yrange [0:]
set xtics 4
set grid y
set ylabel "Commits"
plot 'hour_of_day.dat' using 1:2:(0.5) w boxes fs solid
""")
        f.close()

        # day of week
        f = open(path + '/day_of_week.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'day_of_week.png'
unset key
set xrange [0.5:7.5]
set yrange [0:]
set xtics 1
set grid y
set ylabel "Commits"
plot 'day_of_week.dat' using 1:3:(0.5):xtic(2) w boxes fs solid
""")
        f.close()

        # Domains
        f = open(path + '/domains.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'domains.png'
unset key
unset xtics
set yrange [0:]
set grid y
set ylabel "Commits"
plot 'domains.dat' using 2:3:(0.5) with boxes fs solid, '' using 2:3:1 with labels rotate by 45 offset 0,1
""")
        f.close()

        # Month of Year
        f = open(path + '/month_of_year.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'month_of_year.png'
unset key
set xrange [0.5:12.5]
set yrange [0:]
set xtics 1
set grid y
set ylabel "Commits"
plot 'month_of_year.dat' using 1:2:(0.5) w boxes fs solid
""")
        f.close()

        # commits_by_year_month
        f = open(path + '/commits_by_year_month.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'commits_by_year_month.png'
unset key
set yrange [0:]
set xdata time
set timefmt "%Y-%m"
set format x "%Y-%m"
set xtics rotate
set bmargin 5
set grid y
set ylabel "Commits"
plot 'commits_by_year_month.dat' using 1:2:(0.5) w boxes fs solid
""")
        f.close()

        # commits_by_year
        f = open(path + '/commits_by_year.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'commits_by_year.png'
unset key
set yrange [0:]
set xtics 1 rotate
set grid y
set ylabel "Commits"
set yrange [0:]
plot 'commits_by_year.dat' using 1:2:(0.5) w boxes fs solid
""")
        f.close()

        # Files by date
        f = open(path + '/files_by_date.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'files_by_date.png'
unset key
set yrange [0:]
set xdata time
set timefmt "%Y-%m-%d"
set format x "%Y-%m-%d"
set grid y
set ylabel "Files"
set xtics rotate
set ytics autofreq
set bmargin 6
plot 'files_by_date.dat' using 1:2 w steps
""")
        f.close()

        # Lines of Code
        f = open(path + '/lines_of_code.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set output 'lines_of_code.png'
unset key
set yrange [0:]
set xdata time
set timefmt "%s"
set format x "%Y-%m-%d"
set grid y
set ylabel "Lines"
set xtics rotate
set bmargin 6
plot 'lines_of_code.dat' using 1:2 w lines
""")
        f.close()

        # Lines of Code Added per author
        f = open(path + '/lines_of_code_by_author.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set terminal png transparent size 640,480
set output 'lines_of_code_by_author.png'
set key left top
set yrange [0:]
set xdata time
set timefmt "%s"
set format x "%Y-%m-%d"
set grid y
set ylabel "Lines"
set xtics rotate
set bmargin 6
plot """
)
        i = 1
        plots = []
        for a in self.authors_to_plot:
            i = i + 1
            author = a.replace("\"", "\\\"").replace("`", "")
            plots.append("""'lines_of_code_by_author.dat' using 1:%d title "%s" w lines""" % (i, author))
        f.write(", ".join(plots))
        f.write('\n')

        f.close()

        # Commits per author
        f = open(path + '/commits_by_author.plot', 'w')
        f.write(GNUPLOT_COMMON)
        f.write(
"""
set terminal png transparent size 640,480
set output 'commits_by_author.png'
set key left top
set yrange [0:]
set xdata time
set timefmt "%s"
set format x "%Y-%m-%d"
set grid y
set ylabel "Commits"
set xtics rotate
set bmargin 6
plot """
)
        i = 1
        plots = []
        for a in self.authors_to_plot:
            i = i + 1
            author = a.replace("\"", "\\\"").replace("`", "")
            plots.append("""'commits_by_author.dat' using 1:%d title "%s" w lines""" % (i, author))
        f.write(", ".join(plots))
        f.write('\n')

        f.close()

        os.chdir(path)
        files = glob.glob(path + '/*.plot')
        for f in files:
            out = get_pipe_output([gnuplot_cmd + ' "%s"' % f])
            if len(out) > 0:
                print out

def usage():
    print """
Usage: gitstats [options] <gitpath..> <outputpath>

Options:
-c key=value     Override configuration value

Default config values:
%s

Please see the manual page for more details.
""" % conf


class GitStats:
    def run(self, args_orig):
        optlist, args = getopt.getopt(args_orig, 'hc:', ["help"])
        for o,v in optlist:
            if o == '-c':
                key, value = v.split('=', 1)
                if key not in conf:
                    raise KeyError('no such key "%s" in config' % key)
                if isinstance(conf[key], int):
                    conf[key] = int(value)
                else:
                    conf[key] = value
            elif o in ('-h', '--help'):
                usage()
                sys.exit()

        if len(args) < 2:
            usage()
            sys.exit(0)

        outputpath = os.path.abspath(args[-1])
        rundir = os.getcwd()

        try:
            os.makedirs(outputpath)
        except OSError:
            pass
        if not os.path.isdir(outputpath):
            print 'FATAL: Output path is not a directory or does not exist'
            sys.exit(1)

        if not getgnuplotversion():
            print 'gnuplot not found'
            sys.exit(1)

        print 'Output path: %s' % outputpath
        cachefile = os.path.join(outputpath, 'gitstats.cache')

        data = GitDataCollector()
        data.loadCache(cachefile)

        for gitpath in args[0:-1]:
            print 'Git path: %s' % gitpath

            prevdir = os.getcwd()
            os.chdir(gitpath)

            print 'Collecting data...'
            data.collect(gitpath)

            os.chdir(prevdir)

        print 'Refining data...'
        data.saveCache(cachefile)
        data.refine()

        os.chdir(rundir)
        print 'Generating report...'
        report = HTMLReportCreator()
        report.create(data, outputpath)

        time_end = time.time()
        exectime_internal = time_end - time_start
        exectime_external = get_external_execution_time()
        print 'Execution time %.5f secs, %.5f secs (%.2f %%) in external commands)' \
              % (exectime_internal, exectime_external, (100.0 * exectime_external) / exectime_internal)
        if sys.stdin.isatty():
            print 'You may now run:'
            print
            print '   sensible-browser \'%s\'' % os.path.join(outputpath, 'general.html').replace("'", "'\\''")
            print


if __name__ == '__main__':
    g = GitStats()
    g.run(sys.argv[1:])

